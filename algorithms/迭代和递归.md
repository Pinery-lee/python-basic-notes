# 迭代和递归

迭代：iteration, 重复执行某一过程直到满足某一条件为止。

递归：recursion, 一个函数在执行过程中调用自身。

## 迭代
- for 循环最简单常用。
- while 循环：程序每轮都会先检查条件，如果条件为真，则继续执行，否则退出循环。
- 差异：for 循环是一种更加直观的迭代方式，而 while 循环则更加灵活。for 循环适用于已知循环次数的情况，而 while 循环适用于不确定循环次数的情况。

## 递归
- 递：程序不断深入调用自身，通常传入更小或者更简化的参数，直到达到”终止条件“。
- 归：触发”终止条件“后，程序从最深处的递归函数开始逐层返回，汇聚每一层的结果。
- 三要素：
    - 终止条件：也称初始条件，用于决定什么时候又“递”转“归”。
    - 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。
    - 返回结果：对应“归”，将当前递归层级的结果返回至上一层。

## 迭代和递归的比较
- 迭代：自下而上
- 递归：自上而下
- 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。
    - 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。
    - 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。

## 尾递归
如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。简而言之要在return中进行”递“。

```
def tail_recur(n, res):
    """尾递归"""
    # 终止条件
    if n == 0:
        return res
    # 尾递归调用
    return tail_recur(n - 1, res + n)
```

## 递归树
- 递归会生成一个递归树。
- 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。
- 从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。
    - 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
    - 从数据结构角度看，递归天然适合处理**链表、树和图**的相关问题，因为它们非常适合用分治思想进行分析。


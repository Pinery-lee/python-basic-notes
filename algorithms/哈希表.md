# 哈希表

## 1.增删改查时间复杂度

| 操作     | 数组 | 链表 | 哈希表 |
| -------- | ---- | ---- | ------ |
| 查找元素 | O(n) | O(n) | O(1)   |
| 添加元素 | O(1) | O(1) | O(1)   |
| 删除元素 | O(n) | O(n) | O(1)   |

**在哈希表中进行增删查改的时间复杂度都是O(1)** ，非常高效。

## 2.遍历方式

```python
# 遍历哈希表
# 遍历键值对 key->value
for key, value in hmap.items():
    print(key, "->", value)
# 单独遍历键 key
for key in hmap.keys():
    print(key)
# 单独遍历值 value
for value in hmap.values():
    print(value)
```

python 3.7之后有顺序，顺序就是插入的前后顺序，而python 3.7之前没有

## 3.哈希函数

- 哈希函数是用来把**任意大的输入空间（所有可能的 key）映射到有限的输出空间（哈希值）**。

> 哈希函数（hash function）负责将输入 key 映射为一个整数哈希值。
>  哈希表使用这个哈希值，根据桶的数量（capacity）通过取模或掩码运算计算出该 key 应存储的桶的索引（index）。
>  这样，整个过程分为两步：
>
> 1. 计算哈希值；
> 2. 计算桶索引。

## 4.哈希冲突

- 哈希冲突是当两个或多个不同的键经过哈希函数计算后，得到相同的哈希值，导致映射到哈希表的同一个桶索引时，就发生的哈希冲突。简而言之，两个不同的元素存储到了同一位置。（what)
- 因为哈希函数把一个很大的输入空间映射到了一个固定大小的输出空间（哈希表桶数），根据鸽巢原理，必然有不同输入映射到相同输出。哈希表容量有限，但可能的键的数量巨大或无限。(why)
- 常用的解决哈希冲突的方法主要有两类：

  ### 1. **链地址法（Separate Chaining）**

  - **原理**：哈希表的每个桶不直接存单个元素，而是存一个链表或其他数据结构（如平衡树、链表、数组等）。
  - **操作**：
    - 如果新元素的哈希索引与已有元素冲突，直接把新元素挂到该桶对应链表的尾部。
    - 查找时遍历桶内链表查找目标元素。
  - **优点**：
    - 实现简单，容易扩展。
    - 链表长度不会影响哈希表的整体大小。
  - **缺点**：
    - 如果冲突严重，链表变长，查找效率退化为线性。

  ### 2. **开放寻址法（Open Addressing）**

  - **原理**：所有元素都存储在哈希表数组中，冲突时根据一定的探查策略寻找下一个空桶。
  - **常见探查方式**：
    - **线性探测（Linear Probing）**：冲突时依次检查后续桶。
    - **二次探测（Quadratic Probing）**：冲突时跳跃距离平方增长。
    - **双重哈希（Double Hashing）**：使用第二个哈希函数确定跳跃距离。
  - **优点**：
    - 不需要额外存储指针，节省空间。
    - 当负载因子较低时性能较好。
  - **缺点**：
    - 容易产生“堆积”（clustering）问题。
    - 删除操作比较复杂。

  ------

  ## 3. **再哈希（Rehashing）**

  - 当哈希表负载因子过高（装载率高，冲突多）时，扩容哈希表（桶数量加倍），重新计算所有元素的哈希索引，分散冲突。

  

| 解决方案       | 说明                   | 优点               | 缺点                 |
| -------------- | ---------------------- | ------------------ | -------------------- |
| 链地址法       | 桶存链表或其他结构     | 实现简单，灵活     | 长链表时查找退化     |
| 开放寻址法     | 冲突时探测下一个桶     | 节省空间，缓存友好 | 堆积效应，删除复杂   |
| 再哈希（扩容） | 增加桶数，重新散列元素 | 降低冲突，提升性能 | 扩容时代价大，触发慢 |

负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，**也常作为哈希表扩容的触发条件**。例如在 Java 中，当负载因子超过时，系统会将哈希表扩容至原先的倍。

请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“**不能直接删除元素**”的问题。


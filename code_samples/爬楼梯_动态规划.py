# 记忆化搜索是从上到下
# 动态规划是从下到上
# 由于动态规划不包含回溯过程，所有不需要使用递归，仅仅使用迭代即可
# 三要素：dp表、初始状态、状态转移方程

# 初始化dp表
# 也就对应了记忆化搜索中的memory数组
n = 100
dp = [0] * (n+1)
# 初始状态
dp[1] = 1
dp[2] = 2
# 状态转移方程
for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2]
# 输出结果
print(dp[n])

# 进阶：由于dp[i]只与dp[i-1]和dp[i-2]有关，所以可以只用两个变量来存储dp[i-1]和dp[i-2]，从而节省空间
# 空间复杂度由O(n)降低到O(1)！
# 这种空间优化技巧被称为“滚动变量”或“滚动数组”。
# 优化后的代码如下：

n = 100
a, b = 1, 2
# 状态转移方程  下一次a就等于b, 下一次b就等于上一次a, b的值之和
for i in range(3, n+1):
    a, b = b, a+b
# 输出结果
print(b)
